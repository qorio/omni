package shorty

import (
	"encoding/json"
	"flag"
	"github.com/golang/glog"
	"github.com/gorilla/mux"
	omni_http "github.com/qorio/omni/http"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)

var (
	fingerPrintExpirationMinutes = flag.Int64("fingerprint_expiration_minutes", 2, "Minutes TTL matching by fingerprint")
	fingerPrintMinMatchingScore  = flag.Float64("fingerprint_min_score", 0.8, "Minimum score to match by fingerprint")
)

type AppOpen struct {
	SourceApplication string `json:"sourceApplication"`
	UUID              string `json:"uuid"`
	ShortCode         string `json:"shortCode"`
	Deeplink          string `json:"deeplink"`
}

// /api/v1/events/try/{scheme}/{app_uuid}
// This handler is hit first when the app starts up organically.  So in this case, nothing is known,
// other than the scheme and app_uuid.  So we try to see if there's an existing decode record by the
// same ip address, postal code, region, and country within a specified timeframe.  If there is a match
// then this concludes the install reporting.  Otherwise, we tell the SDK to try again, this time by
// doing the switch through Safari via the public /i/scheme/app_uuid end point opening that URL instead.
func (this *ShortyEndPoint) ApiTryMatchInstallOnOrganicAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	// NO REQUEST BODY

	// That's all now we need to get the ip address etc.
	origin, _ := this.requestParser.Parse(req)
	fingerprint := omni_http.FingerPrint(origin)
	score, visit, _ := this.service.MatchFingerPrint(fingerprint)

	glog.Infoln("Matching fingerprint: score=", score, "visit=", visit)

	// TOOD - make the min score configurable
	// Also make sure the last visit was no more than 5 minutes ago
	if score > *fingerPrintMinMatchingScore && (time.Now().Unix()-visit.Timestamp) < *fingerPrintExpirationMinutes*60 {

		// Good enough - tell the SDK to go on.  No need to try to report conversion
		appOpen := &AppOpen{
			UUID:              visit.UUID,
			SourceApplication: visit.Referrer,
			ShortCode:         visit.ShortCode,
			Deeplink:          visit.Deeplink,
		}
		if err := this.handleInstall(appUrlScheme, appUuid, appOpen, req, "fingerprint"); err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
			return
		}
		if err := this.handleAppOpen(appUrlScheme, appUuid, appOpen, req); err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
			return
		}

		buff, err := json.Marshal(visit)
		if err == nil {
			resp.Write(buff)
		} else {
			renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
			return
		}

	} else {
		// No good.  Tell SDK to try to use the switch method
		resp.WriteHeader(http.StatusNotAcceptable) // 406
	}

}

// /i/{scheme}/{app_uuid}
//
// This is the case where the app starts up without any context or un-referred (not called by
// another application via a deeplink.  So there are no context uuid or short code.  Instead
// the app reports install by performing a GET via a browser like Safari.
func (this *ShortyEndPoint) ReportInstallOnOrganicAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetNoCachingHeaders(resp)

	vars := mux.Vars(req)
	cookies := omni_http.NewCookieHandler(secureCookie, resp, req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	// read the cookies that have been set before when user clicked a short link
	// this allows us to send a redirect as appropriate; otherwise, send a app url with 404
	// a unique user identifier -- generated by us and the lastViewed short code
	lastViewed, userId := "", ""
	userId, _ = cookies.GetPlainString(uuidCookieKey)
	cookies.Get(lastViewedCookieKey, &lastViewed)

	// Construct a AppOpen object using what is read from the http headers / cookies
	appOpen := &AppOpen{
		UUID:              userId,
		ShortCode:         lastViewed,
		Deeplink:          ".", // The app opened itself without referrer
		SourceApplication: "ORGANIC",
	}

	this.handleInstall(appUrlScheme, appUuid, appOpen, req, "browser-switch")
	this.handleAppOpen(appUrlScheme, appUuid, appOpen, req)

	switch {

	case appOpen.ShortCode != "":
		http.Redirect(resp, req, "/"+appOpen.ShortCode, http.StatusMovedPermanently)
		return

	default:
		// Ok to add extra param -- this handler is called only from SDK.
		destination := appUrlScheme + "://404"
		destination = addQueryParam(destination, contextQueryParam, userId)
		http.Redirect(resp, req, destination, http.StatusMovedPermanently)
		return
	}
}

// /api/v1/events/install/{scheme}/{app_uuid}
// Similar to the handler above, this is invoked by SDK client via REST.  This is when the app is launched
// by a deeplink short url, such that the app's referring context are known.  The destination is sent back
// to the client as the api response and not by http redirect.
func (this *ShortyEndPoint) ApiReportInstallOnReferredAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	for {
		if err := dec.Decode(appOpen); err == io.EOF {
			break
		} else if err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if err := this.handleInstall(appUrlScheme, appUuid, appOpen, req, "referred-app-open"); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := this.handleAppOpen(appUrlScheme, appUuid, appOpen, req); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
}

// /api/v1/events/openurl/{scheme}/{app_uuid}
// The payload is a single AppOpen object
// The client POST this to the server when the app opens a deeplink url.
func (this *ShortyEndPoint) ApiReportAppOpenUrl(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	for {
		if err := dec.Decode(appOpen); err == io.EOF {
			break
		} else if err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if err := this.handleAppOpen(appUrlScheme, appUuid, appOpen, req); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
}

func (this *ShortyEndPoint) handleAppOpen(appUrlScheme, appUuid string, appOpen *AppOpen, req *http.Request) error {
	this.service.Link(appOpen.UUID, appUuid, appUrlScheme, appOpen.ShortCode)
	this.service.TrackAppOpen(appUrlScheme, appUuid, appOpen.UUID, appOpen.SourceApplication, appOpen.ShortCode)

	shortUrl, err := this.service.Find(appOpen.ShortCode)
	if err != nil {
		return err
	}

	if shortUrl == nil {
		// Problem - we can't do attribution
		glog.Warningln("cannot-determine-short-code")
	}

	go func() {

		origin, geoParseErr := this.requestParser.Parse(req)
		origin.Destination = appOpen.Deeplink

		installOrigin, installAppKey, installCampaignKey := "NONE", appUrlScheme, "ORGANIC"

		if shortUrl != nil {
			origin.ShortCode = shortUrl.Id
			installOrigin = shortUrl.Origin
			installAppKey = shortUrl.AppKey
			installCampaignKey = shortUrl.CampaignKey
		}

		if geoParseErr != nil {
			glog.Warningln("can-not-determine-location", geoParseErr)
		}

		this.service.PublishAppOpen(&AppOpenEvent{
			RequestOrigin:     origin,
			Destination:       appOpen.Deeplink,
			AppUrlScheme:      appUrlScheme,
			AppUUID:           appUuid,
			SourceUUID:        appOpen.UUID,
			SourceApplication: appOpen.SourceApplication,
			Origin:            installOrigin,
			AppKey:            installAppKey,
			CampaignKey:       installCampaignKey,
		})

		if found, _ := this.service.FindLink(appUuid, appOpen.UUID); !found {
			this.service.PublishLink(&LinkEvent{
				RequestOrigin: origin,
				ShortyUUID_A:  appUuid,
				ShortyUUID_B:  appOpen.UUID,
				Origin:        installOrigin,
				AppKey:        installAppKey,
				CampaignKey:   installCampaignKey,
			})
		}
	}()
	return nil
}

func (this *ShortyEndPoint) handleInstall(appUrlScheme, appUuid string, appOpen *AppOpen, req *http.Request, reportingMethod string) error {

	if appOpen.UUID != "" {
		this.service.Link(appOpen.UUID, appUuid, appUrlScheme, appOpen.ShortCode)
	}

	this.service.TrackInstall(appUuid, appUrlScheme)

	shortUrl, err := this.service.Find(appOpen.ShortCode)
	if err != nil {
		return err
	}

	if shortUrl == nil {
		// Problem - we can't do attribution
		glog.Warningln("cannot-determine-short-code")
	}

	go func() {

		origin, geoParseErr := this.requestParser.Parse(req)
		origin.Destination = appOpen.Deeplink

		installOrigin, installAppKey, installCampaignKey := "NONE", appUrlScheme, "ORGANIC"

		if shortUrl != nil {
			origin.ShortCode = shortUrl.Id
			installOrigin = shortUrl.Origin
			installAppKey = shortUrl.AppKey
			installCampaignKey = shortUrl.CampaignKey
		}

		if geoParseErr != nil {
			glog.Warningln("can-not-determine-location", geoParseErr)
		}

		this.service.PublishInstall(&InstallEvent{
			RequestOrigin:     origin,
			Destination:       appOpen.Deeplink,
			AppUrlScheme:      appUrlScheme,
			AppUUID:           appUuid,
			SourceUUID:        appOpen.UUID,
			SourceApplication: appOpen.SourceApplication,
			Origin:            installOrigin,
			AppKey:            installAppKey,
			CampaignKey:       installCampaignKey,
			ReportingMethod:   reportingMethod,
		})

		if appOpen.UUID != "" {
			if found, _ := this.service.FindLink(appUuid, appOpen.UUID); !found {
				this.service.PublishLink(&LinkEvent{
					RequestOrigin: origin,
					ShortyUUID_A:  appUuid,
					ShortyUUID_B:  appOpen.UUID,
					Origin:        installOrigin,
					AppKey:        installAppKey,
					CampaignKey:   installCampaignKey,
				})
			}
		}

	}()
	return nil
}
