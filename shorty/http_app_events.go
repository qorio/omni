package shorty

import (
	"encoding/json"
	"github.com/golang/glog"
	"github.com/gorilla/mux"
	omni_http "github.com/qorio/omni/http"
	"io/ioutil"
	"net/http"
	"strings"
)

// /api/v1/events/try/{scheme}/{app_uuid}
// This handler is hit first when the app starts up organically.  So in this case, nothing is known,
// other than the scheme and app_uuid.  So we try to see if there's an existing decode record by the
// same ip address, postal code, region, and country within a specified timeframe.  If there is a match
// then this concludes the install reporting.  Otherwise, we tell the SDK to try again, this time by
// doing the switch through Safari via the public /i/scheme/app_uuid end point opening that URL instead.
func (this *ShortyEndPoint) ApiTryMatchInstallOnOrganicAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	app := vars["scheme"]
	if app == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appContext := vars["app_uuid"]
	if appContext == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	// NO REQUEST BODY

	// That's all now we need to get the ip address etc.
	origin, _ := this.requestParser.Parse(req)
	fingerprint := omni_http.FingerPrint(origin)
	score, visit, _ := this.service.MatchFingerPrint(fingerprint)

	glog.Infoln("/api/v1/events/try/: - Matching fingerprint: score=", score, "visit=", visit)

	if visit == nil {
		resp.WriteHeader(http.StatusNotAcceptable) // 406
		return
	}

	// TOOD - make the min score configurable
	// Also make sure the last visit was no more than 5 minutes ago
	if score > *fingerPrintMinMatchingScore && (timestamp()-visit.Timestamp) < *fingerPrintExpirationMinutes*60 {
		go func() {
			appOpen := &AppOpen{
				SourceContext:     visit.Context,
				SourceApplication: visit.Referrer,
				ShortCode:         visit.ShortCode,
				Deeplink:          visit.Deeplink,
			}

			shortUrl, err := this.service.FindUrl(visit.ShortCode)
			if err == nil {
				this.handleInstall(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req, "fingerprint")
				this.handleAppOpen(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req)
			}
		}()

		buff, err := json.Marshal(visit)
		if err == nil {
			resp.Write(buff)
		} else {
			renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
			return
		}
	} else {
		// No good.  Tell SDK to try to use the switch method
		resp.WriteHeader(http.StatusNotAcceptable) // 406
	}
	return
}

// /i/{scheme}/{app_uuid}
//
// This is the case where the app starts up without any context or un-referred (not called by
// another application via a deeplink.  So there are no context uuid or short code.  Instead
// the app reports install by performing a GET via a browser like Safari.
func (this *ShortyEndPoint) ReportInstallOnOrganicAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetNoCachingHeaders(resp)

	vars := mux.Vars(req)
	cookies := omni_http.NewCookieHandler(secureCookie, resp, req)

	app := vars["scheme"]
	if app == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appContext := vars["app_uuid"]
	if appContext == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	// read the cookies that have been set before when user clicked a short link
	// this allows us to send a redirect as appropriate; otherwise, send a app url with 404
	// a unique user identifier -- generated by us and the lastViewed short code
	lastViewed, userId := "", ""
	userId, _ = cookies.GetPlainString(uuidCookieKey)
	lastViewed, _ = cookies.GetPlainString(lastViewedCookieKey)

	// The lastViewed may not be the shortcode, but the interstitial
	sc := lastViewed
	sourceApplication := "ORGANIC"
	deeplink := "."
	method := "browser-switch"
	parts := strings.Split(lastViewed, "/")
	if len(parts) >= 2 && parts[0] == "m" {
		sc = parts[1]
	}

	if len(sc) > 0 {
		// we got the short code by cookie
		glog.Infoln("Browser-switch", "lastViewed=", lastViewed, "sc=", sc, "userId=", userId)
	} else {
		// try fingerprint
		// That's all now we need to get the ip address etc.
		origin, _ := this.requestParser.Parse(req)
		fingerprint := omni_http.FingerPrint(origin)
		score, visit, _ := this.service.MatchFingerPrint(fingerprint)
		glog.Infoln("Matching fingerprint: score=", score, "visit=", visit)
		if score > *fingerPrintMinMatchingScore && (timestamp()-visit.Timestamp) < *fingerPrintExpirationMinutes*60 {
			sc = visit.ShortCode
			deeplink = visit.Deeplink
			sourceApplication = visit.Referrer
			method = "fingerprint"
		}
	}

	go func() {
		appOpen := &AppOpen{
			SourceContext:     UUID(userId),
			ShortCode:         sc,
			Deeplink:          deeplink,
			SourceApplication: sourceApplication,
		}

		shortUrl, err := this.service.FindUrl(appOpen.ShortCode)
		if err == nil {
			this.handleInstall(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req, method)
			this.handleAppOpen(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req)
		}
	}()

	switch {

	case sc != "":
		http.Redirect(resp, req, "/"+sc, http.StatusMovedPermanently)
		return

	default:
		// Ok to add extra param -- this handler is called only from SDK.
		destination := app + "://404"
		destination = addQueryParam(destination, contextQueryParam, userId)
		http.Redirect(resp, req, destination, http.StatusMovedPermanently)
		return
	}
}

// /api/v1/events/install/{scheme}/{app_uuid}
// Similar to the handler above, this is invoked by SDK client via REST.  This is when the app is launched
// by a deeplink short url, such that the app's referring context are known.  The destination is sent back
// to the client as the api response and not by http redirect.
func (this *ShortyEndPoint) ApiReportInstallOnReferredAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	app := vars["scheme"]
	if app == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appContext := vars["app_uuid"]
	if appContext == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	if err := dec.Decode(appOpen); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
		return
	}

	go func() {
		shortUrl, err := this.service.FindUrl(appOpen.ShortCode)
		if err == nil {
			this.handleInstall(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req, "referred-app-open")
			this.handleAppOpen(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req)
		}
	}()
}

// /api/v1/events/openurl/{scheme}/{app_uuid}
// The payload is a single AppOpen object
// The client POST this to the server when the app opens a deeplink url.
func (this *ShortyEndPoint) ApiReportAppOpenUrl(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	app := vars["scheme"]
	if app == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appContext := vars["app_uuid"]
	if appContext == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	if err := dec.Decode(appOpen); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
		return
	}

	go func() {
		shortUrl, err := this.service.FindUrl(appOpen.ShortCode)
		if err == nil {
			this.handleAppOpen(shortUrl, UrlScheme(app), UUID(appContext), appOpen, req)
		}
	}()
}

func (this *ShortyEndPoint) handleAppOpen(shortUrl *ShortUrl, app UrlScheme, appContext UUID, appOpen *AppOpen, req *http.Request) error {
	this.service.Link(app, appOpen.SourceContext, appContext, appOpen.ShortCode)
	appOpen.Timestamp = timestamp()
	appOpen.AppContext = appContext
	this.service.TrackAppOpen(app, appContext, appOpen)

	origin, geoParseErr := this.requestParser.Parse(req)
	origin.Destination = appOpen.Deeplink

	installOrigin, installAccountId, installCampaignId := "NONE", UUID(app), UUID("ORGANIC")

	if shortUrl != nil {
		origin.ShortCode = shortUrl.Id
		installOrigin = shortUrl.Origin
		installAccountId = shortUrl.AccountId
		installCampaignId = shortUrl.CampaignId
	}

	if geoParseErr != nil {
		glog.Warningln("can-not-determine-location", geoParseErr)
	}

	this.service.PublishAppOpen(&AppOpenEvent{
		RequestOrigin:     origin,
		Destination:       appOpen.Deeplink,
		App:               app,
		AppContext:        appContext,
		SourceContext:     appOpen.SourceContext,
		SourceApplication: appOpen.SourceApplication,
		Origin:            installOrigin,
		AccountId:         installAccountId,
		CampaignId:        installCampaignId,
	})

	if found, _ := this.service.FindLink(UUID(appContext), appOpen.SourceContext); !found {
		this.service.PublishLink(&LinkEvent{
			RequestOrigin: origin,
			Context1:      appContext,
			Context2:      appOpen.SourceContext,
			Origin:        installOrigin,
			AccountId:     installAccountId,
			CampaignId:    installCampaignId,
		})
	}
	return nil
}

func (this *ShortyEndPoint) handleInstall(shortUrl *ShortUrl, app UrlScheme, appContext UUID, appOpen *AppOpen, req *http.Request, reportingMethod string) error {
	if appOpen.SourceContext != "" {
		this.service.Link(app, appOpen.SourceContext, appContext, appOpen.ShortCode)
	}

	this.service.TrackInstall(app, appContext)

	origin, geoParseErr := this.requestParser.Parse(req)
	origin.Destination = appOpen.Deeplink

	installOrigin, installAccountId, installCampaignId := "NONE", UUID(app), UUID("ORGANIC")

	if shortUrl != nil {
		origin.ShortCode = shortUrl.Id
		installOrigin = shortUrl.Origin
		installAccountId = shortUrl.AccountId
		installCampaignId = shortUrl.CampaignId
	}

	if geoParseErr != nil {
		glog.Warningln("can-not-determine-location", geoParseErr)
	}

	this.service.PublishInstall(&InstallEvent{
		RequestOrigin:     origin,
		Destination:       appOpen.Deeplink,
		App:               app,
		AppContext:        appContext,
		SourceContext:     appOpen.SourceContext,
		SourceApplication: appOpen.SourceApplication,
		Origin:            installOrigin,
		AccountId:         installAccountId,
		CampaignId:        installCampaignId,
		ReportingMethod:   reportingMethod,
	})

	if appOpen.SourceContext != "" {
		if found, _ := this.service.FindLink(appContext, appOpen.SourceContext); !found {
			this.service.PublishLink(&LinkEvent{
				RequestOrigin: origin,
				Context1:      appContext,
				Context2:      appOpen.SourceContext,
				Origin:        installOrigin,
				AccountId:     installAccountId,
				CampaignId:    installCampaignId,
			})
		}
	}
	return nil
}
