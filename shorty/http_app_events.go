package shorty

import (
	"encoding/json"
	"github.com/golang/glog"
	"github.com/gorilla/mux"
	omni_http "github.com/qorio/omni/http"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
)

type AppOpen struct {
	SourceApplication string `json:"sourceApplication"`
	UUID              string `json:"uuid"`
	ShortCode         string `json:"shortCode"`
	Deeplink          string `json:"deeplink"`
}

// /i/{scheme}/{app_uuid}
//
// This is the case where the app starts up without any context or un-referred (not called by
// another application via a deeplink.  So there are no context uuid or short code.  Instead
// the app reports install by performing a GET via a browser like Safari.
func (this *ShortyEndPoint) ReportInstallOnDirectAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetNoCachingHeaders(resp)

	vars := mux.Vars(req)
	cookies := omni_http.NewCookieHandler(secureCookie, resp, req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	// read the cookies that have been set before when user clicked a short link
	// this allows us to send a redirect as appropriate; otherwise, send a app url with 404
	// a unique user identifier -- generated by us and the lastViewed short code
	lastViewed, userId := "", ""
	userId, _ = cookies.GetPlainString(uuidCookieKey)
	cookies.Get(lastViewedCookieKey, &lastViewed)

	// Construct a AppOpen object using what is read from the http headers / cookies
	appOpen := &AppOpen{
		UUID:              userId,
		ShortCode:         lastViewed,
		Deeplink:          ".", // The app opened itself without referrer
		SourceApplication: ".",
	}

	this.handleInstall(appUrlScheme, appUuid, appOpen, req)
	this.handleAppOpen(appUrlScheme, appUuid, appOpen, req)

	switch {

	case appOpen.ShortCode != "":
		http.Redirect(resp, req, "/"+appOpen.ShortCode, http.StatusMovedPermanently)
		return

	default:
		// Ok to add extra param -- this handler is called only from SDK.
		destination := appUrlScheme + "://404"
		destination = addQueryParam(destination, contextQueryParam, userId)
		http.Redirect(resp, req, destination, http.StatusMovedPermanently)
		return
	}
}

// /api/v1/events/install/{scheme}/{app_uuid}
// Similar to the handler above, this is invoked by SDK client via REST.  This is when the app is launched
// by a deeplink short url, such that the app's referring context are known.  The destination is sent back
// to the client as the api response and not by http redirect.
func (this *ShortyEndPoint) ApiReportInstallOnReferredAppLaunch(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	for {
		if err := dec.Decode(appOpen); err == io.EOF {
			break
		} else if err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if err := this.handleInstall(appUrlScheme, appUuid, appOpen, req); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := this.handleAppOpen(appUrlScheme, appUuid, appOpen, req); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
}

// /api/v1/events/openurl/{scheme}/{app_uuid}
// The payload is a single AppOpen object
// The client POST this to the server when the app opens a deeplink url.
func (this *ShortyEndPoint) ApiReportAppOpenUrl(resp http.ResponseWriter, req *http.Request) {
	omni_http.SetCORSHeaders(resp)

	vars := mux.Vars(req)

	appUrlScheme := vars["scheme"]
	if appUrlScheme == "" {
		renderError(resp, req, "No app customer url scheme", http.StatusBadRequest)
		return
	}

	appUuid := vars["app_uuid"]
	if appUuid == "" {
		renderError(resp, req, "No uuid", http.StatusBadRequest)
		return
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}

	appOpen := &AppOpen{}
	dec := json.NewDecoder(strings.NewReader(string(body)))
	for {
		if err := dec.Decode(appOpen); err == io.EOF {
			break
		} else if err != nil {
			renderJsonError(resp, req, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if err := this.handleAppOpen(appUrlScheme, appUuid, appOpen, req); err != nil {
		renderJsonError(resp, req, err.Error(), http.StatusInternalServerError)
		return
	}
}

func (this *ShortyEndPoint) handleAppOpen(appUrlScheme, appUuid string, appOpen *AppOpen, req *http.Request) error {
	this.service.Link(appOpen.UUID, appUuid, appUrlScheme, appOpen.ShortCode)
	this.service.TrackAppOpen(appUrlScheme, appUuid, appOpen.UUID, appOpen.SourceApplication, appOpen.ShortCode)

	shortUrl, err := this.service.Find(appOpen.ShortCode)
	if err != nil {
		return err
	}

	if shortUrl == nil {
		// Problem - we can't do attribution
		glog.Warningln("cannot-determine-short-code")
	}

	go func() {

		origin, geoParseErr := this.requestParser.Parse(req)
		origin.Destination = appOpen.Deeplink

		installOrigin, installAppKey, installCampaignKey := "NONE", appUrlScheme, "ORGANIC"

		if shortUrl != nil {
			origin.ShortCode = shortUrl.Id
			installOrigin = shortUrl.Origin
			installAppKey = shortUrl.AppKey
			installCampaignKey = shortUrl.CampaignKey
		}

		if geoParseErr != nil {
			glog.Warningln("can-not-determine-location", geoParseErr)
		}
		glog.Infoln("send-to:", appOpen.Deeplink,
			"ip:", origin.Ip, "mobile:", origin.UserAgent.Mobile,
			"platform:", origin.UserAgent.Platform, "os:", origin.UserAgent.OS, "make:", origin.UserAgent.Make,
			"browser:", origin.UserAgent.Browser, "version:", origin.UserAgent.BrowserVersion,
			"location:", *origin.Location,
			"useragent:", origin.UserAgent.Header)

		this.service.PublishAppOpen(&AppOpenEvent{
			RequestOrigin:     origin,
			Destination:       appOpen.Deeplink,
			AppUrlScheme:      appUrlScheme,
			AppUUID:           appUuid,
			SourceUUID:        appOpen.UUID,
			SourceApplication: appOpen.SourceApplication,
			Origin:            installOrigin,
			AppKey:            installAppKey,
			CampaignKey:       installCampaignKey,
		})
	}()
	return nil
}

func (this *ShortyEndPoint) handleInstall(appUrlScheme, appUuid string, appOpen *AppOpen, req *http.Request) error {
	if appOpen.UUID != "" {
		this.service.Link(appOpen.UUID, appUuid, appUrlScheme, appOpen.ShortCode)
	}

	this.service.TrackInstall(appUuid, appUrlScheme)

	shortUrl, err := this.service.Find(appOpen.ShortCode)
	if err != nil {
		return err
	}

	if shortUrl == nil {
		// Problem - we can't do attribution
		glog.Warningln("cannot-determine-short-code")
	}

	go func() {

		origin, geoParseErr := this.requestParser.Parse(req)
		origin.Destination = appOpen.Deeplink

		installOrigin, installAppKey, installCampaignKey := "NONE", appUrlScheme, "ORGANIC"

		if shortUrl != nil {
			origin.ShortCode = shortUrl.Id
			installOrigin = shortUrl.Origin
			installAppKey = shortUrl.AppKey
			installCampaignKey = shortUrl.CampaignKey
		}

		if geoParseErr != nil {
			glog.Warningln("can-not-determine-location", geoParseErr)
		}
		glog.Infoln("send-to:", appOpen.Deeplink,
			"ip:", origin.Ip, "mobile:", origin.UserAgent.Mobile,
			"platform:", origin.UserAgent.Platform, "os:", origin.UserAgent.OS, "make:", origin.UserAgent.Make,
			"browser:", origin.UserAgent.Browser, "version:", origin.UserAgent.BrowserVersion,
			"location:", *origin.Location,
			"useragent:", origin.UserAgent.Header)

		this.service.PublishInstall(&InstallEvent{
			RequestOrigin:     origin,
			Destination:       appOpen.Deeplink,
			AppUrlScheme:      appUrlScheme,
			AppUUID:           appUuid,
			SourceUUID:        appOpen.UUID,
			SourceApplication: appOpen.SourceApplication,
			Origin:            installOrigin,
			AppKey:            installAppKey,
			CampaignKey:       installCampaignKey,
		})
	}()
	return nil
}
